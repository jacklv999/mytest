## 软件工程：软件设计

[TOC]

#### 1、先设计，后编码

每个学过软件工程的人都不应该对这句话感到陌生；但真正能理解它、实践它的人并不多。

先设计，后编码，它的意义在于，我们首先要从整体上搞明白这个项目可不可行、都有哪些方案、这些方案都有哪些优劣势，以及不同方案可能带来哪些风险、如何应对……

事实上，业界公认，需求 / 设计阶段应该占软件开发总时长的 60%；但这 60%使得后面的 40%没了悬念，最终整个项目反而能更快、更轻松的上线，且上线后极少有棘手 bug。

打个比方的话，这就好像开车去北京一样：先设计，后编码要求你先看看地图，大概总结一下去北京有几条路线、路上补给容不容易、消费高不高、容不容易被气候影响，等等。

心里有了谱，那么当埋头开发时才不会被细节弄花眼：

没有事先规划，想哪写哪；结果被层出不穷的状况（**还美其名曰需求变更**）牵着鼻子、面多了加水水多了加面：这就是绝大多数软件开发时间冗长、状况不断、无疾而终的根本原因。

#### 2、写“明显没有错误”的代码，不要写“没有明显错误”的代码

很简单，除非你真的做了设计，否则你的代码当然不会有什么“设计感”——信马由缰淌出来的，怎么可能有“整齐的设计感”。

你必须先用心设计，找出所有可以到达目标的路径中、最短最快消耗最低的那一条。

只有先做到这一点，你才能把代码写简单，才能让人一眼看出意图、明显没有缺陷。

但把很复杂的功能写简单、写的让人一眼看懂、而且很确定“这里明显没有错误”，反而需要极深的功底。

尤其一项技术 / 一个领域发展成熟之前，第一个把它写成大白话的，哪个都是业界大拿。

#### 3、学最激进的技术，用最简单的实现

我们应该学习最激进的东西；但只用那些能把工程变得更简单的技术。

注意，我可没说“学最激进的东西，但千万不要用它”或者“学最激进的东西，然后一定要用它”哦。

我说的是：

- 第一，最激进的东西要了解；
- 第二，只用足够稳定的东西；
- 第三，也是最重要的一点，技术无所谓先进落后，能最简单平易解决问题的，就是最好的技术。

——因此，我会在大部分公司视 STL 为洪水猛兽时，自己在工程中实现模板算法，因为只有模板才能最简洁直观的完成我当时面对的问题。

#### 4、把可变的东西隔离到配置数据里

请记住，不要把配置参数固化在代码里！相反，如果真的有需求，请使用配置参数来动态改变类的行为——更严苛更复杂的需求，不妨实现成 DSL。

**开闭原则**：

- 对修改封闭：程序代码写出来就**不用**再动了，这叫；
- 对扩展开放：**所有新功能，都可以借助既有的代码完成**。

你看，当你搞出个 DSL 时，是不是整个领域的一切都能借助它来完成？这是不是最彻底的“对扩展开放”？

同时，用户都被你隔离到 DSL 那一侧了，你的基本库是不是用就行了、再也**用不着也不应该**修改？这是不是最彻底的“对扩展开放”？

总之，设计程序，请一定要记住：**我们只写固定不变的东西**；经常会变的东西，我们**只写 hold 住它变化的那一点精华**（此所谓 meta 编程），所有可能变化的东西都应该隔离到数据中去。

**业务数据与业务模型**：

请一定要区分开“业务模型”和“业务数据”；甚至于，请特别警惕，不要被用户自己描述的“业务模型”带歪了：具体的某个公司的组织结构也只是数据，他们这些外行哪能给你合理的总体设计！

你得自己琢磨对方的组织结构和信息流程，思考下“如果业务部不再从属于客户部，而是独立出来、改名为‘服务部’，和客户部并列，那我的程序该怎么办”……

你看，这才叫“需求变更”——那些半吊子那种“从一开始就没弄明白、搞了两年了才发现一开始弄错了得改”，那叫“需求事故”，可不是什么需求变更。

#### 5、多考虑意外情况，不要只实现 happy path

所谓 happy path，就是完全不考虑出错、不考虑数据竞争、不考虑操作提交时条件不满足、假定世界是完美的、按顺序来一切都能解决的这么一个执行流。

嗯，如你所见，很多人 happy path 都还设计不好呢……

但，如果你有所追求的话，就别只盯着 happy path。

请从你的小的、玩具级别的项目开始，训练自己同时考虑 happy path 和异常退出时的执行流——甚至是异常恢复流。

做大一些的、需要长时间运行的项目，不会处理异常是不可能的。

当然，happy path 也是必须先找出来的。

先把 happy path 找出来，再一点点添加——这里可能出现意外，出现意外怎么办……逐渐添加、丰富下去，正确的设计稿就出来了。

#### 6、在设计时就考虑好异常处理途径和应对方案

这一条看似和上一条重复了；但实际上是上一条的深化。

异常处理是需要在设计阶段就考虑好的。

首先，要把异常分为几类。

> 比如，用户输入数据本身的错误、网络错误、磁盘数据被破坏、宇宙射线造成位反转，等等。

然后，对确定来源的异常应设计正常处理流程——它是正常流程的一部分，是设计之初就应该考虑好的，可不是什么异常。

> 比如，用户输入数据过不了检测，那就打回去让用户重填。
> 网络连接出错呢，要给用户提示；如果用户提交了数据，那么可以考虑把这份数据先存在本地（注意数据安全），或者提示他等网络好了重做。
> 特别的，有些时候，用户的一连串动作整体构成一个“事务”，比如加购物车、下单、付款、送货、确认收货等。这一系列动作，其中的每一个可以做成“原子”的，比如付款要么成功、要么不成功；但整个事务要允许暂停、要记住每一步的状态——然后，无论用户手机重启还是我们服务器宕机，其中的每一步都要记录在案，绝不能有丝毫差错。

之后，对未知来路的奇怪错误，不要姑息——见到了，就让程序崩掉。

> 这是因为，此时，我们可能是遇到了宇宙射线，也可能被人缓冲区溢出攻击——或者我们自己错误覆写了某个数据结构。
> 此时程序的状态是不可控的，它犯任何错误都有可能。
> 我们不应该寄希望奇迹发生、程序突然自己就好了——它好不了。甚至，它真突然“表现正常”了，那才可怕呢：说明我们最最不想见到的情况出现了（比如，黑客成功控制了它，抹去了一切异常痕迹……）
>
> 因此，正确的做法就是：让程序立即崩溃！

最终，如果我们的程序的确有极高可靠性要求的话，我们需要设计一个机制，及早发现程序崩溃并自动拉起新的实例。

> 举例来说，apache 就非常“激进”：默认的，每个 php 解释器实例在接受过 50 次页面请求后，哪怕没有任何异常，apache 都会强行杀死它、重新拉起一个实例来。
>
> 这是因为，很多时候，程序的异常状态需要存在很久、持续扩散、到了某个“病入膏肓”的状态，才能被迟钝的我们感知。
> 因此，当安全特别重要时，我们不妨假定“一个响应过 50 次请求的解释器已经出错了、甚至被黑客攻陷了”——立即杀死它并启动新的实例，对于 Linux 这种起一个进程消耗极低（仅需一个 fork 而已）的 OS 来说，几乎没有可观测的额外负担，但却可以最大限度的保障系统的可靠性。
>
> 所以说，不要把“程序崩溃”看作洪水猛兽。我们 hold 得住它。
> 不仅如此，及早让出现了位置状况的程序崩溃，我们也能更容易的找到问题根源——趁着犯罪现场尚未被破坏及早立案侦察，这才能确保罪犯（bug）无处可逃。

如此反复，最终就是：一出错就马上抛异常崩溃掉的程序，出错的机率越来越低、渐至于怎么折腾都不会崩溃、甚至单实例都能 7x24 小时可靠运行；而使劲容错、绝不崩溃的程序，它几乎每时每刻都在出错、逼得用户不得不“重启下说不定就好了”“这破系统用十分钟就得重启，不然丢数据……不是丢新数据，旧数据都会被破坏……”

#### 7、有时候要把用户当作“敌人”防范

请把用户看成“专门来捣乱的”，甚至看成“无孔不入的黑客”——而你，要写一个程序，经受他们的“严刑拷打”却依然可靠运行。

这听起来很难，做起来……嗯，也没那么容易。

但只要你愿意往这方面努力，却也没那么高不可攀——绝对不是什么“黑客无可匹敌，我们只能俯首称臣”……没那回事。

黑客说白了，也就是个“偏安全侧的白盒测试工程师”——你会怕测试工程师吗？

那你干嘛怕黑客。

#### 8、复用的诀窍：只做一件事，把一件事做好

前面关于软件工程的讨论可能吓到你了：妈耶，写一个可以应对需求变更的东西好难！

其实一点也不难：只做一件事，把一件事做好，这玩意儿就天然是方便复用的。

这很容易理解。

玩过积木吧？

什么样的积木摆什么造型都用得上？

方块，对吧。

软件也一样。

你往里面添加了越多的“高级功能”“自动化机制”，它就越发的只能为它的设计目标服务了——稍微改一点？重写吧。

反之，你把功能简化到简无可简、不让它保存什么在状态，而是用户给什么数据它提供什么服务……那么，很自然的，用户拿它来做什么都可以。

Linux 的 grep、awk 等犀利的文本工具，其实就是这么来的。

这实际上也是我前面说过的：**把可变的东西隔离到数据中**，程序只提供一组元规则！

把具体事务相关的东西隔离出去、只写程序处理“共性”……越是这样，你的程序越简洁。

程序越简洁，就越是可以随意的拼起来、拼出千变万化五彩缤纷的大千世界。

#### 9、学习测试理论，遵循规范，利用工具，有章法的编写程序

前面“藐视”了一把黑客，恐怕不少不学无术者未免要“友邦惊诧”了。

但实际上，这个并不难，也是有专业的、现成的体系的——而且有现成的课本，拿来学就是了。

比如，前面我提到“要把用户当敌人”，恐怕很多人就想不通了：不是，你是不知道，用户能有多奇葩……

不仅可以预想到，甚至测试理论还帮我们压缩了负担。

比如说，一个人机界面（UI），用户的输入有无穷多种，这怎么测？

简单，划分等价类。

什么叫等价类？

就是把数据分为若干类。合法数据程序必须给出正确响应；非法数据程序必须明确拒绝。

比如，我们这个程序负责收钱，金额上限 100，下限为 0，精确到小数点后两位小数。

那么，[100, 0]就是合法数据。

(0, -∞)和(100, +∞)就是非法数据。

abc 也是非法数据

我们不需要测试所有这些数字——那不可能做到；但我们可以从每一类里选择几个进行测试。

因为程序也是针对集合进行判断的，因此，每类数据选择一两个代表就行了，足以涵盖所有情况。

然后，一般人经常犯错的，刚刚好介于合法和非法之间的数据，这叫“临界值”，比如 -0.1、0、0.1、99.99、100、100.01 都是边界值——注意边界值和合法 / 非法数据并不是同一层面的东西——我们最好也都找出来，测一测。

不仅如此。

有些数据，虽然接口上看都属于合法数据；但内部处理呢，可能大于 30 块钱的走转账、小于 30 块钱走快捷支付——你看，其实这里也要分成两个等价类，这才能覆盖所有流程，对吧。

同样的，这里也会有新的边界值，比如 29.99、30、30.01 之类。

#### 10、正确认识测试和开发的关系

最熟悉软件的就是程序员自己。

哪怕他们能做到，写程序这件事也是程序员在干，轮不到他们。

那么，怎样才能把一个程序写的简洁、好测、可以“明显没有问题”呢？

换句话说，**测试测出来、没有 bug 的代码，那叫“没有明显的缺陷”；而程序员写出来就没有 bug 的代码，那才叫“明显没有缺陷”**。

想要做到“写明显没有错误的代码”，想要走到这个层次，你就得训练自己，让自己对缺陷敏感、能够持续产出“测试友好”的代码，甚至一出手就是成品，就没人能找到 bug。

#### 11、敏捷 / 测试驱动开发是以上的演进而不是替代

这个又是国内普遍的、不学无术环境下养成的严重错误认知。

典型的瀑布式开发，高级工程师要从需求到详设全部包揽，只留一些空函数给程序员填。这种模式对高级工程师要求很高，但对写代码的工程师要求很低，会填空即可。缺点是过于僵死，项目周期长；而且容易搞出庞大、累赘的方案。太容易走进“重分解、轻复用”的误区。

敏捷其实也是瀑布式开发，也需要从需求到总体设计到模块设计走上一遭；但它同时又汲取了“自底向上”模式和“快速原型法”的长处。

它要求程序员写出可复用的、库函数水平的代码，这样才可以根据需要随意组合（自底向上开发模式）；它也要求程序员做出可复用的设计、做好模块分解，这样需求变更才不会对程序造成过大冲击（这是瀑布模型）；最后，它先做基本功能，让客户看到样子，再一点点改（这是快速原型法）。

换句话说，敏捷的“先写用例后写代码”，实际上是以单元测试代替详细设计文档、以高质量的面向对象的类定义代替模块设计、总体设计文档，从而把写文档的时间直接拿来写代码——然后借助面向对象框架直接导出文档就行了。

后来改成“先写测试，后写代码”——说白了，详细设计文档没人想写，写文档的功夫就把代码写出来了；而且经常写完了文档，才发现实际实现时遇到了问题，还得回头改文档……

先写测试，其实就是定内部功能划分和接口设计。不然没法写测试用例。写完测试再写代码，写出来就能马上跑一下测试，确保接口正确——倘若发现了问题，那就改测试用例（也就是改接口）：反正总是要测的，改一下很自然，不多费工。

换句话说，现在只要求普通程序员有详细设计的能力，那就足够玩敏捷了——至于模块设计、总体设计、需求等等，那当然还是得专人来做。