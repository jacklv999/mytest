## 二叉搜索树

#### 定义

BST具有一定的特点：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

#### 创建BST

有序列表可以使用递归直接创建BST

```python
def ToBST(self, nums):
    if not nums:
        return None
    mid = len(nums) // 2
    root = TreeNode(nums[mid])
    root.left = self.ToBST(
        nums[:mid]
    )
    root.right = self.ToBST(
        nums[mid+1:]
    )
    return root
```

#### BST转列表

BST的最重要的一个特性是：中序遍历可以让BST输出有序列表！！！！   

#### BST搜索

在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

```python
def searchBST(self, root, val):
        while root:
            if root.val==val:
                return root
            if root.val>val:
                root=root.left
            else:
                root=root.right
        return
```

#### BST最近公共祖先

利用二叉搜索树的特点，如果p、q的值都小于root，说明p q 肯定在root的左子树中；如果p q都大于root，说明肯定在root的右子树中，如果一个在左一个在右 则说明此时的root记为对应的最近公共祖先 

递归版本

```python
def lowest(self, root, p, q):
    if p.val<root.val and q.val<root.val:
        return self.lowest(root.left,p,q)
        
    if p.val>root.val and q.val>root.val:        
        return self.lowest(root.right,p,q)
        
    return root
```

非递归版本

```python
def lowest(self, root, p, q):
    r1=max(p.val,q.val)
    r2=min(p.val,q.val)
    while root :
        if root.val>=r2 and root.val<=r1:
            return root
        if root.val>r1:
            root=root.left
        else:
            root=root.right
    return root
```

