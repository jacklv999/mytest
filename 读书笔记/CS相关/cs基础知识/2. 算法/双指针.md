## 双指针

#### 1. 普通双指针

双指针是一种非常常用的技巧，在下面的示例中，利用双指针遍历两个数组，然后依次对比数据。

```python
p_1, p_2 = 0, 0
res = []
while (
    p_1 < len(L1)
) & (
    p_2 < len(L2)
):
    if L1[p_1] == L2[p_2]:
        res.append(L1[p_1])
        p_1 += 1
        p_2 += 1
    elif L1[p_1] > L2[p_2]:
        p_2 += 1
    else:
        p_1 += 1
```

#### 2. 快慢指针

快慢指针使用两个指针分别遍历链表，快指针每次移动两格，慢指针每次移动一格。因此，两个指针的速度差为一，在循环链表中两个指针的距离每次减少一。

```python
def hasCycle(
    self, 
    head: Optional[ListNode]
) -> bool:
    fast, slow = head, head
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
        if fast == slow:
            return True

    return False
```

#### 3. 滑动窗口

##### 模板一

以右指针作为驱动，拖着左指针向前走。

右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。

右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

```python
def maxArray(self, 
             nums: List[int]
            ) -> int:
    num_sum = list()
    right = 0
    while right <= len(nums):
        left = 0
        while right > left:
            num_sum.append(sum(
                nums[left:right]
            ))
            left += 1
        right += 1
    return max(num_sum)
```

##### 模板二

以左指针作为驱动，右指针向前探索。

```python
def maxArray(self, 
             nums: List[int]
            ) -> int:
    num_sum = list()
    left = 0
    while left < len(nums):
        right = left + 1
        while right <= len(nums):
            num_sum.append(sum(
                nums[left:right]
            ))
            right += 1
        left += 1
    return max(num_sum)
```
