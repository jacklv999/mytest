## 动态规划

#### 1. 几个简单的概念

##### 【无后效性】

一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。

要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。

**“未来与过去无关”，**这就是**无后效性**。

（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）

##### 【最优子结构】

回顾我们对f(n)的定义：我们记“凑出n所需的**最少**钞票数量”为f(n).

f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的**最优**解，我们即可算出w=15的**最优**解。

大问题的**最优解**可以由小问题的**最优解**推出，这个性质叫做“最优子结构性质”。

#### 2. DP的边界

引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？

**能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。**

DP的核心思想：**尽量缩小可能解空间。** 

##### 【如何设计DP算法】

下面介绍比较通用的设计DP算法的步骤。

首先，把我们面对的**局面**表示为x。这一步称为**设计状态**。
对于状态x，记我们要求出的答案(e.g. 最小费用)为f(x).我们的目标是求出f(T).
**找出f(x)与哪些局面有关（记为p）**，写出一个式子（称为**状态转移方程**），通过f(p)来推出f(x).

##### 【DP三连】

设计DP算法，往往可以遵循DP三连：

- 我是谁？ ——设计状态，表示局面
- 我从哪里来？
- 我要到哪里去？ ——设计转移

设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑“我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，**更新能从x走到的一些解**。这种DP也是不少的，我们以后会遇到。

总而言之，“我从哪里来”和“我要到哪里去”只需要考虑清楚其中一个，就能设计出状态转移方程，从而写代码求解问题。前者又称pull型的转移，后者又称push型的转移。

### 案例

「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的，希望大家能够通过本题题解进一步体会状态是如何想到的（即子问题的定义需要从哪些方面考虑）。

本题接的重点在「关键 1：理解题意」和「关键 2：如何定义子问题（如何定义状态）」和「最后再谈谈「无后效性」。

#### 关键 1：理解题意

题目要我们找出和最大的连续子数组的值是多少，「连续」是关键字，连续很重要，不是子序列。

题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

#### 关键 2：如何定义子问题（如何定义状态）

设计状态思路：把不确定的因素确定下来，进而把子问题定义清楚，把子问题定义得简单。动态规划的思想通过解决了一个一个简单的问题，进而把简单的问题的解组成了复杂的问题的解。

#### 过程

我们 不知道和最大的连续子数组一定会选哪一个数，那么我们可以求出 所有 经过输入数组的某一个数的连续子数组的最大和。

例如，示例 1 输入数组是 [-2,1,-3,4,-1,2,1,-5,4] ，我们可以求出以下子问题：

- 子问题 1：经过 -2 的连续子数组的最大和是多少
- 子问题 2：经过 1 的连续子数组的最大和是多少
- 子问题 3：经过 -3的连续子数组的最大和是多少
- 子问题 4：经过 4的连续子数组的最大和是多少

一共 9 个子问题，这些子问题之间的联系并没有那么好看出来，这是因为 子问题的描述还有不确定的地方（这件事情叫做「有后效性」，我们在本文的最后会讲解什么是「无后效性」）。

例如「子问题 3」：经过 -3−3 的连续子数组的最大和是多少。

「经过 -3−3 的连续子数组」我们任意举出几个：

- [-2,1,-3,4] ，-3−3 是这个连续子数组的第 3 个元素；
- [1,-3,4,-1] ，-3−3 是这个连续子数组的第 2 个元素；
- ……

我们不确定的是：-3−3 是连续子数组的第几个元素。那么我们就把 -3−3 定义成连续子数组的最后一个元素。在新的定义下，我们列出子问题如下：

- 子问题 1：以-2结尾的连续子数组的最大和是多少
- 子问题 2：以1结尾的连续子数组的最大和是多少
- 子问题 3：以-3结尾的连续子数组的最大和是多少
- 子问题 4：以 4结尾的连续子数组的最大和是多少

我们加上了「结尾的」，这些子问题之间就有了联系。我们单独看子问题 1 和子问题 2：

- 子问题 1：以 -2结尾的连续子数组的最大和是多少；

以 -2结尾的连续子数组是 [-2]，因此最大和就是 -2。

- 子问题 2：以 1结尾的连续子数组的最大和是多少；

以 1结尾的连续子数组有 [-2,1] 和 [1] ，其中 [-2,1] 就是在「子问题 1」的后面加上 1 得到。-2 + 1 = -1 < 1 ，因此「子问题 2」 的答案是 1。

大家发现了吗，如果编号为 i 的子问题的结果是负数或者 0 ，那么编号为 i + 1 的子问题就可以把编号为 i 的子问题的结果舍弃掉（这里 i 为整数，最小值为 1 ，最大值为 8），这是因为：

- 一个数 a 加上负数的结果比 a 更小；
- 一个数 a 加上 0的结果不会比 a 更大；

而子问题的定义必须以一个数结尾，因此如果子问题 i 的结果是负数或者 0，那么子问题 i + 1 的答案就是以 `nums[i]` 结尾的那个数。

> 因为我们把子问题定义的更清楚，子问题之间的联系就容易观察到。这是我们定义子问题、定义状态的经验。

接下来我们按照编写动态规划题解的步骤，把「状态定义」「状态转移方程」「初始化」「输出」「是否可以空间优化」全都写出来。

#### 定义状态（定义子问题）

> dp[i]：表示以 nums[i] 结尾 的 连续 子数组的最大和。

**说明**：「结尾」和「连续」是关键字。

#### 状态转移方程（描述子问题之间的联系）

根据状态的定义，由于 nums[i] 一定会被选取，并且以 nums[i] 结尾的连续子数组与以 nums[i - 1] 结尾的连续子数组只相差一个元素 nums[i] 。

假设数组 nums 的值全都严格大于 00，那么一定有 dp[i] = dp[i - 1] + nums[i]。

可是 dp[i - 1] 有可能是负数，于是分类讨论：

- 如果 dp[i - 1] > 0，那么可以把 nums[i] 直接接在 dp[i - 1] 表示的那个数组的后面，得到和更大的连续子数组；
- 如果 dp[i - 1] <= 0，那么 nums[i] 加上前面的数 dp[i - 1] 以后值不会变大。于是 dp[i] 「另起炉灶」，此时单独的一个 nums[i] 的值，就是 dp[i]。

以上两种情况的最大值就是 dp[i] 的值，写出如下状态转移方程：

$$dp[i] = \max \{nums[i],\; dp[i - 1] + nums[i]\}$$ 

记为「状态转移方程 」。

友情提示：求解动态规划的问题经常要分类讨论，这是因为动态规划的问题本来就有「最优子结构」的特点，即大问题的最优解通常由小问题的最优解得到。因此我们在设计子问题的时候，就需要把求解出所有子问题的结果，进而选出原问题的最优解。

#### 思考初始值

dp[0] 根据定义，只有 1 个数，一定以 nums[0] 结尾，因此 dp[0] = nums[0]。

#### 思考输出

注意：

> 这里状态的定义不是题目中的问题的定义，不能直接将最后一个状态返回回去；

重要的事情说三遍，有时候写东西写得多了，怕读者看不到重点，所以会想方设法进行强调，一句话翻来覆去反复说。我以前和一个在新东方当英语老师的朋友交流过，这样的效果最好。大家可以理解为职业病，我们更多是想要照顾到新手朋友们。大佬要是觉得我讲得啰嗦了，还请忽略。

简单的动态规划问题，很有可能问的问题就可以设计成为子问题，复杂的动态规划问题就没有那么容易看出子问题应该如何设计了，这需要一定的解决问题的经验。

这个问题的输出是把所有的 dp[0]、dp[1]、……、dp[n - 1] 都看一遍，取最大值。 同样的情况也适用于「力扣」第 300 题：「最长上升子序列」（以后我们有空，再把这道题拿出来再讲一遍，超级超级重要的一道动态规划问题）。

可以优化空间吗
根据「状态转移方程」，dp[i] 的值只和 dp[i - 1] 有关，因此可以使用「滚动变量」的方式将代码进行优化。

参考代码：

```python
def maxSubArray(
    self, nums: List[int]
) -> int:
    size = len(nums)
    if size == 0:
        return 0
    dp = [0 for _ in range(size)]
    dp[0] = nums[0]
    for i in range(1, size):
        if dp[i - 1] >= 0:
            dp[i] = dp[i - 1] + nums[i]
        else:
            dp[i] = nums[i]
    return max(dp)
```

时间复杂度：O(N)O(N) ，这里 NN 是输入数组的长度。
