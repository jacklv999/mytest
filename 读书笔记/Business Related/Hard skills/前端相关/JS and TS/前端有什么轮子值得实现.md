# 前端有什么轮子值得实现？

#### lodash

最有必要而且最简单的轮子应该是lodash了，这个轮子里面的每个函数都非常简单小巧，学习难度低，而且在业务开发中很实用，实现它并不是“面试造火箭入职拧螺丝”的操作，而是真正有实际价值可以学到并且加速业务开发的事情。而且这里面很多写法是面试的easy题目

#### ahooks

做React开发还可以学一学ahooks，这是阿里开源的一个react hook库，里面也包含了很多业务开发中非常实用的小函数，相当于是react hook界的lodash。

#### babel-JSX转换器

如果是科班有学习过编译原理，可以尝试着用anltr或者yacc等codegen工具写一个babel-JSX转换器，把JSX语法转换成使用JS Object组成的Virtual-DOM。因为JSX的关键词较少（基本上就是HTML标签里面那几个符号），并且语法很简答（就是HTML互相嵌套，并且HTML里面可以写[attribute](https://www.zhihu.com/search?q=attribute&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2006336708})），所以理论来说只需要学会编译原理中的编译器前端和[parser](https://www.zhihu.com/search?q=parser&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2006336708})的基本概念部分，借助现有的非常成熟的anltr等工具就能写出来



前面提到了写JSX转换Virtual-DOM的parser，但是仅仅只有一个parser还是不够，react的核心是单项数据流，状态变更触发视图变更，视图变更使用diff算法加速，而这一切核心在HTML上都是react-dom这个库实现的（主要是ReactDOM.render这个函数），因此可以尝试着手动实现一个react-dom，把ReactDOM.render这个函数实现，如果觉得自己水平不够，可以先不做diff差异渲染，而是做全量渲染，也就是任何一个组件的state或者props变更，都立即重新render一遍[根组件](https://www.zhihu.com/search?q=根组件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2006336708})，从代码层面理解单项数据流和 UI=render(props) 这个公式背后的意义是什么。

如果你想进一步挑战，可以尝试[朴素diff算法](https://www.zhihu.com/search?q=朴素diff算法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2006336708})，也就是同时深度优先遍历Virtual-DOM树和[HTML DOM树](https://www.zhihu.com/search?q=HTML+DOM树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2006336708})，比较出现不同的地方，然后进行修补